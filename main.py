import argparse
import json
from itertools import islice
import webbrowser
import re

from rdioapi import Rdio


class SearchError(StandardError):
    def __init__(self, tracks):
        self.tracks = tracks
        super(StandardError, self).__init__()

class APIError(StandardError): pass

def playlist():
    with open('songlist.json') as f:
        return json.load(f)

class PersistantRdio(object):

    def __init__(self, dest):
        self._dest = dest

        try:
            self._rstate = self._load_state()
        except IOError:
            self._rstate = {}

        with open('credentials.json') as f:
            creds = json.load(f)

        self.r = Rdio(creds['key'], creds['secret'], self._rstate)
        if not self.r.authenticated:
            self.authorize()

    def _save_state(self):
        with open(self._dest, "w") as f:
            json.dump(self._rstate, f)

    def _load_state(self):
        with open(self._dest) as f:
            return json.load(f)

    def authorize(self):
        auth_url = self.r.begin_authentication('http://example.com')
        webbrowser.open(auth_url)
        verifier = input("oauth verifier: ")
        # token = input("token: ")
        self.r.complete_authentication(verifier)

        self._save_state()


class Client(object):
    def __init__(self, rdio, playlist):
        self._rdio = rdio
        assert self._r.authenticated
        self._query_re = re.compile(r"\(.+\)")
        self.playlist = playlist
        self.success = 0
        self.count = 0
        self.failures = []

    @property
    def _r(self):
        return self._rdio.r

    def _clean_result(self, result):
        if result['track_count'] < 1:
            raise SearchError(result['track_count'])
        if result['track_count'] > 1:
            print "%s tracks. picking first." % result['track_count']
        print "success"
        return result['results'][0]['key']

    def _query(self, song):
        # query = " ".join(['%s' % x for x in song.values()])
        query = " ".join([
            song['artist'],
            song['title']
        ])
        query.replace(" EP ", " ")
        return self._query_re.sub("", query).encode('utf8')

    def _get_track(self, query):
        result = self._r.call(
            'search',
            query=query,
            types="Track"
        )
        return self._clean_result(result)

    def get_tracks(self, limit):

        songs = playlist()
        if limit > 0:
            songs = islice(songs, limit)

        for song in songs:
            query = self._query(song)
            try:
                print "\n\tlooking up track [%s]" % query
                yield self._get_track(query)
                self.success += 1
            except SearchError, e:
                print "Found %s tracks. not processing %s" % (e.tracks, song)
                self.failures.append(song)
            except APIError, e:
                print "Issue looking up track %s. Status %s" % (song, e.message)
            except Exception, e:
                print e
            self.count += 1

    def do(self, limit):
        tracks = ", ".join(self.get_tracks(limit))
        print tracks

        playlist = self._r.call(
            'createPlaylist',
            name=self.playlist,
            description="autogenerated by mwhooker",
            tracks=tracks
        )


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='create playlist from song list')
    parser.add_argument('playlist', type=str,
                       help='which playlist to add songs to')
    parser.add_argument('--count', type=int, default=10,
                       help='How many songs to process. < 1 means no limit.')
    parser.add_argument('--dry-run', action="store_true",
                        help="Don't create playlist")

    args = parser.parse_args()
    r = PersistantRdio('.rdio')
    c = Client(r, args.playlist)
    if args.dry_run:
        for song in c.get_tracks(args.count):
            print song
    else:
        c.do(args.count)

    print "%s out of %s songs successfully processed." % (c.success, c.count)
    print "the following songs failed to return results:"
    print "\n".join(map(json.dumps,c.failures))
